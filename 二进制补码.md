# 计算机为什么选用二进制补码（一）?


## 原码、反码、补码

 1.概念
 
	1).数在计算机中是以二进制形式表示的；
	2).数分为有符号数和无符号数；
	3).原码、反码、补码都是有符号定点数的表示方法；
	4).无符号数全部按正数处理；
	5).一个有符号定点数的最高位为符号位，0是正，1是负；


#### 2.反码、补码定义:

	正数：
	原码=反码=补码
	
	负数：
	原码
	反码=其原码除符号位之外的各位求反
	补码=反码+1  （如果+1之后有进位的，要一直往前进位，包括符号位）


#### 3.运算示例
	正零：00000000
	负零：10000000
	这两个数其实都是0，但他们的原码却有不同的表示。
	特别注意，如果+1之后有进位的，要一直往前进位，包括符号位！（这和反码是不同的！）
	[10000000]补
	=[10000000]反+1
	=11111111+1
	=(1)00000000
	=00000000(最高位溢出了，符号位变成了0）
	
	那么10000000这个补码表示的哪个数的补码呢？
	其实这是一个规定，这个数表示的是-128
	所以n位补码能表示的范围是
	-2^(n-1)到2^(n-1)-1
	比n位原码能表示的数多一个

##### 例1：
	1011
	原码：01011
	反码：01011 //正数时，反码＝原码
	补码：01011 //正数时，补码＝原码
	
	-1011
	原码：11011
	反码：10100 //负数时，反码为原码取反
	补码：10101 //负数时，补码为原码取反＋1
	
##### 例2：
	0．1101
	原码：0.1101
	反码：0.1101 //正数时，反码＝原码
	补码：0.1101 //正数时，补码＝原码
	
	-0．1101
	原码：1.1101
	反码：1.0010 //负数时，反码为原码取反
	补码：1.0011 //负数时，补码为原码取反＋1
  
#### 4.几个特殊定义：
	n位补码能表示的范围：有符号数是 -2^(n-1)到2^(n-1)-1  无符号数是 0-2^n-1
	-128的补码是10000000， -128+1=-127 ，(-127)补=10000001=10000000+00000001 符合运算规则
	0的补码00000000
	
	

# 计算机为什么选用二进制补码（二）?

#### 1.补码本身具有幂等性：该特性决定我们虽然运算使用补码，但是通过两次补码可以回到原码；
	（（X)补）补=X
	a+b=(a补+b补)补
   
#### 2.补码解决了正0 负0的二义性，使0的表示得到统一；
	正零：00000000
	负零：10000000
	这两个数其实都是0，但他们的原码却有不同的表示。
	但是他们的补码是一样的，都是00000000


#### 3.CPU将加，减法统一为加法运算；
	[a-b]补=a补+（-b）补


#### 4.使符号位能与有效值部分一起参加运算，从而简化运算规则。
	补码机器数中的符号位，并不是强加上去的，是数据本身的自然组成部分，
	可以正常地参与运算。CPU并不知道正负，使其能够按照和无符号数一致的运算规则进行处理；


#### 5.补码使二进制的加、减、移位等操作和十进制具有相同的运算规律；

#### 6.负数-a实际上使用0-a结果，通过二进制运算0-a就是-a的补码，由此可见定义补码就是要求所有算术运算符合现有的运算规律；

#### 补码意义：
	所以补码的设计目的是：
	
	⑴ 使符号位能与有效值部分一起参加运算，从而简化运算规则。补码机器数中的符号位，并不是强加上去的，是数据本身的自然组成部分，可以正常地参与运算。
	
	⑵ 使减法运算转换为加法运算，进一步简化计算机中运算器的线路设计。
	
	所有这些转换都是在计算机的最底层进行的，而在我们使用的汇编、c等其他高级语言中使用的都是原码。
	
	CPU对于补码完全不知情，其只按照指令机械的按照电路设计进行工作，并对某些溢出标志位进行设置；
	所有的逻辑由编译器来决定，处理的数是有符号数还是无符号数，有符号数出现溢出怎么处理，这些在编译时已经确定；
	编译器送给机器的机器代码中：负数已经进行补码编码，同时编译器负数对负数结果进行转换为原码或10进制数据显示给用户；
	
	
	
	
# 计算机为什么选用二进制补码（三）--有符号数界限?

	阿拉伯数字只有一个0, 但是按照计算机的处理应该有两个0，一个+0，一个-0；
	假设是8位，+0和-0的原码分别是：
	+0=0000 0000  -0=1000 0000
	但是他们的补码是一样的，都是00000000，因此0的补码形式只有一种：
	那就是0000 0000
	
	那8位二进制有符号整数能表示的最大范围是多少呢？
	如果按照原码进行表示，1111 1111 -    0111 1111 即：
	-127 到+127  再加一个0  ，255个数字；
	但是教科书上又明明说8位二进制有符号整数的范围是：-128 到+127,即 -2^(n-1)到2^(n-1)-1
	这又是为什么？
	原因就是计算机运算时使用补码进行的，
	1000 0000  这个数字被强制规定就是-128的补码：
	-128+1=-127
	（1000 0000 ）补+（0000 0001）补=1000 0001 
	-127的补码就是1000 0001 ，符合运算规律；
	故n位有符号数表示的范围是： -2^(n-1) 到 2^(n-1)-1
	故n位无符号数表示的范围是：0  到2^n-1
	
	8位二进制有符号整数中：-128是没有原码的，其原码不存在，原码中有两个0，即+0和-0。
	
	
	
	
# 计算机为什么选用二进制补码（四）--CPU怎么看有符号数和无符号数?
	
	
#### 1.计算机内存中存放的数值型数据是由编译器处理后保存的；

#### 2.CPU根本不区分有符号数值还是无符号数值，CPU按照相同的运输规律进行计算，并设置相关Flags位，由程序自己决定解释是有符号运算还是无符号运算；

#### 3.如果应用程序逻辑标示的是负数，则编译器送入CPU寄存器的数值都是补码形式标示；

#### 4.引入补码的原因是：
	一是：CPU将加，减法统一为加法运算；
	二是：补码对加、减、移位等操作具有幂等性。

#### 5.有符号数的加减法，CUP只会设置相应的进位标志寄存器和溢出标志寄存器，
	由程序员（汇编程序员）或高级程序语言编译器决定将进位作为符号位，还是数值位；

#### 6.有符号数和无符号数的乘除法，CUP有不同的指令分别处理；

#### 7.CPU可以有硬件阵列乘法器或除法器，
	也可以通过加减，与，或，非，异或等模拟乘除运算。
	书中写到： 
	mov al，10000001B 
	add al，1 
	可以将add指令进行的运算当作无符号数的运算，也可以将add指令进行的运算当作有符号数的运算。 

#### 问题： 
	到底是当作有符号还是无符号数。 
	
	我认为：执行了上面两条指令后，SF标志值肯定是一定的。所以有无符号运算也是定好的。问题就是，我怎么知道进行的是有符号运算还是无符号运算。 
	
	CPU处理一个二进制数时，其实也无法知道这个数是有符号还是无符号数；
	由于引入了补码，使得加减计算的指令对有符号数和无符号数的处理是一样的，
	所以加减运算时CPU将运算结果作为有符号数和无符号数对符号位的影响都“罗列”出来了，
	供编程者根据需要使用；乘除运算有符号数和无符号数所用的指令是不同的。 
	那么如何判断一个数究竟是有符号数还是无符号数呢？如果程序（本质上是编程者）
	把最高位用作符号位，这就是有符号数；如果把最高位作为有效数位，那就是无符号数了。
	    
	cpu在执行add等指令时，是必然要影响到SF标志位的值的。至于我们需不需要这种影响，那就看我们如何看待指令所进行
	的运算了。 也就是说，到底是有符号数还是无符号数，是有我们来决定的。
	
	这个sf为正还是为负实际上就是计算机运算后给符号位定一个值，是1还是0,我明白了，
	在附注的补码中就是说，当最高位为1就代表负数，那么就是当计算后数第一个数为1时，sf也就是1了
	
	在汇编语言里面：
	加减其实不分是有符号还是无符号的，主要依靠用户自己判断，
	在进行完加减操作以后，对CF, OF两个寄存器进行判断，如有无近位和溢出。
	而在乘除计算的时候，则有相应的不同的机器代码对计算数字进行不同的处理。
	
	对于高级语言C，由编译器根据源程序做出判断是有符号还是无符号,再翻译成汇编程序处理；
	
	对于乘除法：CPU有不同的指令
	读与加减：CPU按照统一格式进行处理，
	原因是有无符号运算结构一致（原因是计算机采用补码进行运算决定的）